* Working through cs6120
** lesson 1
cool
** lesson 2
bril's json IR,

terminators (jumps rets etc),
and making a (label-annotated) CFG to do dead code removal

I wrote a 'springboard' transform, that inserts a call to a springboard function before all calls in the program.
This is a more silly version of what some dynamic binary instrumentation frameworks do to observe program behavior.

I also wrote a basic benchmark that computes sin via polynomial approximation.

I implemented elamdf/cfg.py in lesson-2 branch of my [[github.com/elamdf/bril][bril fork]] which,
assuming globally unique labels,
produces the cfg for a bril program.
It could probably merge things more aggressively,
and I don't really understand the 'fold functions into basic blocks' thing because,
while that makes sense wrt the strict definition of a basic block (called functions are promised to execute),
it kind of makes it hard to decide when a ffunction is dead,
since the function label is never referenced regardless of if it's called.

Maybe you just directly look at the code within the blocks though,
rather than discrete functions.
We could just flatten the block lists for each function and compute cfg if you wanted to do this kind of analysis.xb
** lesson 3
lvn is cool! I got it to replace some subexpressions and achieve some dramatic improvements in dynamic variable count on some of the benchmarks.

Some of the benchmarks were claimed 'incorrect' by brench but I spot checked running them manually with brili and they seemd fine.
The problematic benchmarks for brench seemd to be ones with args/turnt attributes.
** lesson 4
dataflow is cool!
I implemented the backwards version of the workman algorithm from the lecture's pseudocode,
as well as the merge (union) and transfer (see impl) functions to find the live range of variables.

They match the .live outputs for the 3 example (cond, cond-args, and fact) tests in =examples/test/df=. Woohoo!
